/**
 * Coglog 2.6.1 - Probabilistic, Reflective, Self-Executing Logic Engine (Ollama Version)
 *
 * Implemented in a single Node.js file using LangChain.js (with Ollama) for LLM interaction.
 * Focuses on compactness, correctness, and minimal comments during debugging.
 *
 * Usage:
 * 1. Install dependencies: `npm install uuid @langchain/community`
 * 2. Ensure Ollama is running (e.g., `ollama serve`) and the model is pulled (e.g., `ollama pull llama3`)
 * 3. Run: `node coglog.js`
 */

// === Dependencies ===
import { randomUUID } from 'crypto';
import { ChatOllama } from "@langchain/community/chat_models/ollama"; // Ollama Integration
import { HumanMessage } from "@langchain/core/messages";
import fs from 'fs/promises';
import path from 'path';

// === Configuration ===
const config = Object.freeze({
    persistenceFile: 'coglog_state.json',
    maxRetries: 3,
    pollIntervalMillis: 100,
    maxActiveDurationMillis: 60000, // Increased timeout for local LLMs
    gcIntervalMillis: 60 * 60 * 1000,
    gcThresholdMillis: 24 * 60 * 60 * 1000,
    ollamaBaseUrl: process.env.OLLAMA_BASE_URL || "http://localhost:11434", // Default Ollama URL
    llmModelName: process.env.OLLAMA_MODEL || "llamablit", // Default Ollama model (ensure it's pulled)
    logLevel: process.env.COGLOG_LOG_LEVEL || 'info',
    maxBeliefValue: Number.MAX_SAFE_INTEGER,
});

// === Logging ===
const logger = {
    debug: (...args) => config.logLevel === 'debug' && console.debug('[DEBUG]', new Date().toISOString(), ...args),
    info: (...args) => ['debug', 'info'].includes(config.logLevel) && console.info('[INFO]', new Date().toISOString(), ...args),
    warn: (...args) => ['debug', 'info', 'warn'].includes(config.logLevel) && console.warn('[WARN]', new Date().toISOString(), ...args),
    error: (...args) => console.error('[ERROR]', new Date().toISOString(), ...args),
};

// === Constants ===
const Role = Object.freeze({ NOTE: 'NOTE', GOAL: 'GOAL', STRATEGY: 'STRATEGY', OUTCOME: 'OUTCOME', META_THOUGHT: 'META_THOUGHT' });
const Status = Object.freeze({ PENDING: 'PENDING', ACTIVE: 'ACTIVE', WAITING_CHILDREN: 'WAITING_CHILDREN', DONE: 'DONE', FAILED: 'FAILED' });

// === Data Structures ===
class TermBase { applySubstitution(subMap){return this} toJSON(){return{type:this.type,...this}} toString(){return this._toString()} _toString(){throw Error("Impl _toString")} equals(other){return this===other||(other instanceof TermBase&&this.toString()===other.toString())} }
class Atom extends TermBase { type='Atom'; constructor(name){super();if(typeof name!=='string'||!name)throw Error("Atom name non-empty string");this.name=name;Object.freeze(this)} _toString(){return this.name} }
class Variable extends TermBase { type='Variable'; constructor(name){super();if(typeof name!=='string'||!(name.startsWith('_')||/^[A-Z]/.test(name)))throw Error(`Invalid Var name:"${name}"`);this.name=name;Object.freeze(this)} _toString(){return this.name} applySubstitution(subMap){let curr=subMap.get(this.name);let visited=new Set();while(curr instanceof Variable&&subMap.has(curr.name)&&!visited.has(curr.name)){visited.add(curr.name);const next=subMap.get(curr.name);if(next===curr||(next instanceof Variable&&next.name===curr.name))break;curr=next} return(curr&&curr!==this&&curr instanceof TermBase)?curr.applySubstitution(subMap):this} }
class NumberTerm extends TermBase { type='NumberTerm'; constructor(value){super();if(typeof value!=='number'||!Number.isFinite(value))throw Error("NumberTerm finite num");this.value=value;Object.freeze(this)} _toString(){return this.value.toString()} }
class Structure extends TermBase { type='Structure'; constructor(name,args){super();if(typeof name!=='string'||!name)throw Error(`Struct name non-empty str (got:${name})`);if(!Array.isArray(args)||!args.every(arg=>arg instanceof TermBase)){const invArgs=Array.isArray(args)?args.filter(a=>!(a instanceof TermBase)).map(a=>typeof a):'not arr';throw Error(`Struct args arr of Terms. Invalid:${invArgs} in Struct(${name},...)`)} this.name=name;this.args=Object.freeze([...args]);Object.freeze(this)} _toString(){return`${this.name}(${this.args.map(a=>a.toString()).join(', ')})`} applySubstitution(subMap){const newArgs=this.args.map(arg=>{if(!(arg instanceof TermBase)){logger.error(`Non-Term in Struct args sub:${arg}`);return arg}return arg.applySubstitution(subMap)});return newArgs.every((newA,i)=>newA===this.args[i])?this:new Structure(this.name,newArgs)} }
class ListTerm extends TermBase { type='ListTerm'; constructor(elements){super();if(!Array.isArray(elements)||!elements.every(el=>el instanceof TermBase)){const invEls=Array.isArray(elements)?elements.filter(el=>!(el instanceof TermBase)).map(el=>typeof el):'not arr';throw Error(`ListTerm elems arr of Terms. Invalid:${invEls}`)} this.elements=Object.freeze([...elements]);Object.freeze(this)} _toString(){return`[${this.elements.map(e=>e.toString()).join(', ')}]`} applySubstitution(subMap){const newElems=this.elements.map(el=>{if(!(el instanceof TermBase)){logger.error(`Non-Term in ListTerm elems sub:${el}`);return el}return el.applySubstitution(subMap)});return newElems.every((newE,i)=>newE===this.elements[i])?this:new ListTerm(newElems)} }
class Belief { constructor(pos,neg){if(!Number.isFinite(pos)||!Number.isFinite(neg)||pos<0||neg<0)throw Error(`Invalid Belief counts: p=${pos}, n=${neg}.`);this.positive=Math.min(pos,config.maxBeliefValue);this.negative=Math.min(neg,config.maxBeliefValue);Object.freeze(this)} score(){const t=this.positive+this.negative;return t===0?0.5:t>Number.MAX_SAFE_INTEGER/2?this.positive/t:(this.positive+1.0)/(t+2.0)} update(posSig){return posSig?new Belief(this.positive+1.0,this.negative):new Belief(this.positive,this.negative+1.0)} static DEFAULT_POSITIVE=Object.freeze(new Belief(1.0,0.0));static DEFAULT_UNCERTAIN=Object.freeze(new Belief(0.0,0.0));static DEFAULT_LOW_CONFIDENCE=Object.freeze(new Belief(0.1,0.9)); toJSON(){return{positive:this.positive,negative:this.negative}} static fromJSON(json){return(json&&typeof json.positive==='number'&&typeof json.negative==='number')?new Belief(json.positive,json.negative):(logger.warn("Invalid Belief JSON",json),Belief.DEFAULT_UNCERTAIN)} }
class Thought { constructor(id,role,content,belief,status,metadata){if(typeof id!=='string'||id.length!==36)throw Error(`Inv ID:${id}`);if(!Object.values(Role).includes(role))throw Error(`Inv Role:${role}`);if(!(content instanceof TermBase))throw Error(`Inv Content:${content?.constructor?.name}`);if(!(belief instanceof Belief))throw Error(`Inv Belief:${belief?.constructor?.name}`);if(!Object.values(Status).includes(status))throw Error(`Inv Status:${status}`);if(typeof metadata!=='object'||metadata===null)throw Error("Meta obj");this.id=id;this.role=role;this.content=content;this.belief=belief;this.status=status;this.metadata=Object.freeze({...metadata});Object.freeze(this)} toBuilder(){return new ThoughtBuilder(this)} toJSON(){return{id:this.id,role:this.role,content:this.content.toJSON(),belief:this.belief.toJSON(),status:this.status,metadata:{...this.metadata}}} static fromJSON(json){try{return new Thought(json.id,json.role,termFromJSON(json.content),Belief.fromJSON(json.belief),json.status,json.metadata||{})}catch(e){logger.error(`Err reconstruct Thought ID ${json?.id}:${e.message}`);throw e}} }
class ThoughtBuilder { constructor(t){this.id=t.id;this.role=t.role;this.content=t.content;this.belief=t.belief;this.status=t.status;this.metadata={...t.metadata}} _updateMeta(k,v){this.metadata[k]=v;this.metadata['last_updated_timestamp']=Date.now();return this} setRole(r){this.role=r;return this} setContent(c){this.content=c;return this} setBelief(b){this.belief=b;return this} setStatus(s){this.status=s;this._updateMeta('last_updated_timestamp',Date.now());return this} setMetadata(k,v){return this._updateMeta(k,v)} replaceMetadata(m){this.metadata={...m,last_updated_timestamp:Date.now()};return this} build(){return new Thought(this.id,this.role,this.content,this.belief,this.status,this.metadata)} }
function termFromJSON(json){if(!json||typeof json!=='object'||!json.type)throw Error(`Inv JSON Term:${JSON.stringify(json)}`);try{switch(json.type){case'Atom':return new Atom(json.name);case'Variable':return new Variable(json.name);case'NumberTerm':return new NumberTerm(json.value);case'Structure':return new Structure(json.name,json.args.map(termFromJSON));case'ListTerm':return new ListTerm(json.elements.map(termFromJSON));default:throw Error(`Unk Term type:${json.type}`)}}catch(e){throw Error(`Err reconstruct Term ${json.type}(nest:${e.message})`)}}

// === Helper Functions ===
const generateUUID = () => randomUUID();
function unify(t1,t2,initSub=new Map()){const sub=new Map(initSub);const stack=[[t1,t2]];while(stack.length>0){let[u1,u2]=stack.pop();u1=resolveVariable(u1,sub);u2=resolveVariable(u2,sub);if(u1===u2||(u1 instanceof Atom&&u2 instanceof Atom&&u1.name===u2.name)||(u1 instanceof NumberTerm&&u2 instanceof NumberTerm&&u1.value===u2.value))continue;if(u1 instanceof Variable){if(occursCheck(u1,u2,sub))return null;sub.set(u1.name,u2);continue} if(u2 instanceof Variable){if(occursCheck(u2,u1,sub))return null;sub.set(u2.name,u1);continue} if(u1 instanceof Structure&&u2 instanceof Structure&&u1.name===u2.name&&u1.args.length===u2.args.length){for(let i=0;i<u1.args.length;i++)stack.push([u1.args[i],u2.args[i]]);continue} if(u1 instanceof ListTerm&&u2 instanceof ListTerm&&u1.elements.length===u2.elements.length){for(let i=0;i<u1.elements.length;i++)stack.push([u1.elements[i],u2.elements[i]]);continue} return null} return sub}
function resolveVariable(term,sub){let visited=null;while(term instanceof Variable&&sub.has(term.name)){const bound=sub.get(term.name);if(bound===term||(bound instanceof Variable&&bound.name===term.name))return term;if(visited?.has(term.name))return term;if(!visited)visited=new Set();visited.add(term.name);term=bound} return term}
function occursCheck(variable,term,sub){term=resolveVariable(term,sub);if(variable===term||(variable instanceof Variable&&term instanceof Variable&&variable.name===term.name))return true;if(!(term instanceof Variable||term instanceof Structure||term instanceof ListTerm))return false;const stack=[term];const visited=new Set();while(stack.length>0){const curr=resolveVariable(stack.pop(),sub);if(variable===curr||(variable instanceof Variable&&curr instanceof Variable&&variable.name===curr.name))return true;if(!curr||visited.has(curr))continue;if(curr instanceof Structure){visited.add(curr);curr.args.forEach(a=>stack.push(a))}else if(curr instanceof ListTerm){visited.add(curr);curr.elements.forEach(e=>stack.push(e))}} return false}
function applySubstitution(term,subMap){if(!(term instanceof TermBase))throw Error(`Cannot sub non-Term:${term}`);if(!(subMap instanceof Map))throw Error(`Sub map must be Map`);return term.applySubstitution(subMap)}
function sampleWeighted(items){if(!Array.isArray(items)||items.length===0)return null;const valid=items.filter(([s,i])=>typeof s==='number'&&Number.isFinite(s)&&s>0&&i!==undefined&&i!==null);if(valid.length===0)return null;const total=valid.reduce((sum,[s])=>sum+s,0);if(total<=0)return null;let r=Math.random()*total;for(const[s,i]of valid){r-=s;if(r<=0)return i} return valid[valid.length-1][1]}

// === External Service Wrappers ===
class LlmService { constructor(){ logger.info(`Initializing Ollama service: Model=${config.llmModelName}, BaseURL=${config.ollamaBaseUrl}`); this.client=new ChatOllama({baseUrl:config.ollamaBaseUrl,model:config.llmModelName})} async invoke(prompt){if(!this.client)throw Error("LLM Service not init.");logger.debug(`Ollama Call prompt:"${prompt.substring(0,100)}..."`);try{const res=await this.client.invoke([new HumanMessage(prompt)]);const content=res?.content;if(typeof content!=='string')throw Error(`Ollama resp not string:${content}`);logger.debug(`Ollama Resp received:"${content.substring(0,100)}..."`);return content}catch(e){const errMsg=e?.response?.data?.error?.message||e?.message||'Unk Ollama API err';logger.error(`Ollama invocation failed:${errMsg}`);throw Error(`Ollama API call failed:${errMsg}`)}}}
class PersistenceService { constructor(fp){this.filePath=path.resolve(fp);logger.info(`Persistence path:${this.filePath}`)} async save(map){logger.debug(`Persisting ${map.size} thoughts...`);const tmp=this.filePath+'.tmp';try{const data=Array.from(map.values()).map(t=>t.toJSON());await fs.writeFile(tmp,JSON.stringify(data,null,2));await fs.rename(tmp,this.filePath);logger.debug(`Persist OK.`)}catch(e){logger.error(`Save state failed:`,e);try{await fs.unlink(tmp)}catch(_){}throw e}} async load(){logger.debug(`Loading state from ${this.filePath}...`);try{const data=await fs.readFile(this.filePath,'utf-8');const jsonArr=JSON.parse(data);if(!Array.isArray(jsonArr))throw Error("File not JSON arr.");const map=new Map();let inv=0;jsonArr.forEach((j,i)=>{try{const t=Thought.fromJSON(j);if(map.has(t.id)){logger.warn(`Dup ID "${t.id}" load skip ${i}.`);inv++}else map.set(t.id,t)}catch(e){logger.warn(`Skip inv thought ${i} load:${e.message}`);inv++}});logger.info(`Loaded ${map.size} thoughts. Skipped ${inv} inv.`);return map}catch(e){if(e.code==='ENOENT'){logger.info(`File ${this.filePath} not found. Starting fresh.`);return new Map()}logger.error(`Load state failed:`,e);logger.warn("Proceeding empty state.");return new Map()}}}
class StoreNotifier { notify(type,thought){logger.debug(`Notifier:${type.toUpperCase()} - ID:${thought.id},St:${thought.status}`)} }
class TextParserService { parse(txt){if(typeof txt!=='string'||!txt.trim())return null;logger.debug(`Parsing input:"${txt}"`);return new Thought(generateUUID(),Role.NOTE,S("user_input",A(txt)),Belief.DEFAULT_POSITIVE,Status.PENDING,{creation_timestamp:Date.now(),last_updated_timestamp:Date.now()})} }

// === Core Components ===
const executionContext={currentMetaThoughtId:null};
class ThoughtStore { constructor(ps,sn){this.thoughts=new Map();this.persistenceService=ps;this.storeNotifier=sn;this._savingPromise=null;this._saveQueued=false} async loadState(){this.thoughts=await this.persistenceService.load()} async persistState(){if(this._savingPromise){this._saveQueued=true;logger.debug("Persist queued.");return} this._savingPromise=this.persistenceService.save(this.thoughts).catch(e=>logger.error("BG persist failed:",e)).finally(async()=>{this._savingPromise=null;if(this._saveQueued){this._saveQueued=false;logger.debug("Starting queued persist.");await this.persistState()}})} getThought(id){return this.thoughts.get(id)} addThought(t){if(!(t instanceof Thought))throw Error("Can only add Thought");if(this.thoughts.has(t.id)){logger.warn(`Skip add dup ID:${t.id}.`);return} this.thoughts.set(t.id,t);logger.debug(`Added ${t.id}(${t.role},${t.status})`);this.storeNotifier.notify('add',t);this.persistState()} updateThought(oldT,newT){if(!(newT instanceof Thought)||!(oldT instanceof Thought))throw Error("Update needs Thoughts");if(oldT.id!==newT.id)throw Error("Cannot change ID on update");const curr=this.thoughts.get(oldT.id);if(!curr){logger.warn(`Update non-exist ID:${oldT.id}`);return false} if(curr!==oldT){logger.warn(`Update conflict ID:${oldT.id}. Rejected.`);return false} const metaId=executionContext.currentMetaThoughtId;let prov=Array.isArray(newT.metadata.provenance)?[...newT.metadata.provenance]:[];if(metaId&&!prov.includes(metaId))prov.push(metaId);const finalMeta={...newT.metadata,provenance:Object.freeze(prov),last_updated_timestamp:newT.metadata.last_updated_timestamp||Date.now()};const thoughtToStore=new Thought(newT.id,newT.role,newT.content,newT.belief,newT.status,finalMeta);this.thoughts.set(thoughtToStore.id,thoughtToStore);logger.debug(`Updated ${thoughtToStore.id}->St:${thoughtToStore.status},B:${thoughtToStore.belief.score().toFixed(3)}`);this.storeNotifier.notify('update',thoughtToStore);this.persistState();return true} removeThought(id){const t=this.thoughts.get(id);if(t&&this.thoughts.delete(id)){logger.debug(`Removed ${id}`);this.storeNotifier.notify('remove',t);this.persistState();return true} return false} getMetaThoughts(){return Array.from(this.thoughts.values()).filter(t=>t.role===Role.META_THOUGHT)} findThoughtsByParentId(pId){return Array.from(this.thoughts.values()).filter(t=>t.metadata?.parent_id===pId)} samplePendingThought(){const items=[];for(const t of this.thoughts.values()){if(t.status===Status.PENDING){const s=t.belief.score();if(s>0)items.push([s,t])}} if(items.length===0)return null;const sel=sampleWeighted(items);if(sel)logger.debug(`Sampled PENDING ${sel.id}(Score:${sel.belief.score().toFixed(3)})from ${items.length}.`);else if(items.length>0)logger.warn(`Weighted sample null despite ${items.length} PENDING`);return sel} getAllThoughts(){return Array.from(this.thoughts.values())} getStatusCounts(){const c={PENDING:0,ACTIVE:0,WAITING_CHILDREN:0,DONE:0,FAILED:0};for(const t of this.thoughts.values())if(c[t.status]!==undefined)c[t.status]++;return c} }
class Unifier { findAndSampleMatchingMeta(activeT,allMetaT){logger.debug(`Unifying ${activeT.id}(${activeT.content.toString()})vs ${allMetaT.length} META...`);const matches=[];for(const meta of allMetaT){if(!(meta.content instanceof Structure)||meta.content.name!=='meta_def'||meta.content.args.length!==2){logger.warn(`Skip inv META ${meta.id}:${meta.content.toString()}`);continue} const target=meta.content.args[0];const sub=unify(target,activeT.content);if(sub!==null){const score=meta.belief.score();logger.debug(`Potential match:${activeT.id} vs META ${meta.id}(Target:${target.toString()},Score:${score.toFixed(3)})`);if(score>0)matches.push({metaThought:meta,substitutionMap:sub,score:score});else logger.debug(`Skip match META ${meta.id} score ${score}.`)}} if(matches.length===0){logger.debug(`No matching META for ${activeT.id}`);return{hasMatch:false}} const sel=sampleWeighted(matches.map(m=>[m.score,m]));if(sel){logger.info(`Selected META ${sel.metaThought.id}(Score:${sel.score.toFixed(3)})for ${activeT.id}`);return{hasMatch:true,matchedMetaThought:sel.metaThought,substitutionMap:sel.substitutionMap}}else{logger.warn(`Weighted sample failed META match for ${activeT.id} despite ${matches.length}.`);return{hasMatch:false}}} }
class ActionExecutor { constructor(ts,tg,ls){this.thoughtStore=ts;this.thoughtGenerator=tg;this.llmService=ls;this.primitiveActions={'add_thought':this._addThought.bind(this),'set_status':this._setStatus.bind(this),'set_belief':this._setBelief.bind(this),'check_parent_completion':this._checkParentCompletion.bind(this),'generate_thoughts':this._generateThoughts.bind(this),'sequence':this._sequence.bind(this),'call_llm':this._callLlm.bind(this),'log_message':this._logMessage.bind(this),'no_op':this._noOp.bind(this)}} async execute(activeT,metaT,subMap){executionContext.currentMetaThoughtId=metaT.id;let resActionTerm;try{logger.debug(`Executing action from META ${metaT.id} for ${activeT.id}`);const actTempl=metaT.content.args[1];resActionTerm=applySubstitution(actTempl,subMap);logger.debug(`Resolved Action:${resActionTerm.toString()}`);if(!(resActionTerm instanceof Structure))throw Error(`Resolved action not Struct:${resActionTerm.toString()}`);const actName=resActionTerm.name;const actArgs=resActionTerm.args;const actMeth=this.primitiveActions[actName];if(!actMeth)throw Error(`Unk primitive action:${actName}`);const success=await actMeth(activeT,actArgs,subMap);if(!success)logger.warn(`Primitive "${actName}" reported failure for ${activeT.id}.`);else logger.debug(`Primitive "${actName}" OK.`);return success}catch(e){logger.error(`Err exec action "${resActionTerm?.name||'unk'}" for ${activeT.id} from META ${metaT.id}:`,e);throw e}finally{executionContext.currentMetaThoughtId=null}}
    async _addThought(activeT,args){if(args.length<2||args.length>3||!(args[0]instanceof Atom)||!(args[1]instanceof TermBase))throw Error("Inv args add_thought");const rName=args[0].name.toUpperCase();const role=Role[rName];if(!role)throw Error(`Inv role add_thought:${rName}`);const content=args[1];let belief=Belief.DEFAULT_UNCERTAIN;if(args.length===3){if(!(args[2]instanceof Atom))throw Error("Belief arg Atom");const bTypeName=args[2].name.toUpperCase();const bMap={'POSITIVE':Belief.DEFAULT_POSITIVE,'UNCERTAIN':Belief.DEFAULT_UNCERTAIN,'LOW_CONFIDENCE':Belief.DEFAULT_LOW_CONFIDENCE,'NEGATIVE':new Belief(0.0,1.0)};belief=bMap[bTypeName]||(logger.warn(`Unk belief type ${args[2].name}. Using UNCERTAIN.`),Belief.DEFAULT_UNCERTAIN)} const newT=new Thought(generateUUID(),role,content,belief,Status.PENDING,{parent_id:activeT.id,creation_timestamp:Date.now(),last_updated_timestamp:Date.now()});this.thoughtStore.addThought(newT);return true}
    async _setStatus(activeT,args){if(args.length!==1||!(args[0]instanceof Atom))throw Error("Inv args set_status");const sName=args[0].name.toUpperCase();const newS=Status[sName];if(!newS)throw Error(`Inv status:${sName}`);if(newS===Status.ACTIVE)throw Error("Cannot set status ACTIVE");const curr=this.thoughtStore.getThought(activeT.id);if(!curr){logger.warn(`Thought ${activeT.id} not found during set_status.`);return false} if(curr.status===newS)return true;const updatedT=curr.toBuilder().setStatus(newS).build();const success=this.thoughtStore.updateThought(curr,updatedT);if(!success)logger.warn(`Failed update ${activeT.id} status ${newS}(conflict?).`);return success}
    async _setBelief(activeT,args){if(args.length!==1||!(args[0]instanceof Atom))throw Error("Inv args set_belief");const sigType=args[0].name.toUpperCase();let posSig;if(sigType==='POSITIVE')posSig=true;else if(sigType==='NEGATIVE')posSig=false;else throw Error(`Inv belief signal:${sigType}`);const curr=this.thoughtStore.getThought(activeT.id);if(!curr){logger.warn(`Thought ${activeT.id} not found set_belief.`);return false} const updatedB=curr.belief.update(posSig);if(updatedB.positive===curr.belief.positive&&updatedB.negative===curr.belief.negative)return true;const updatedT=curr.toBuilder().setBelief(updatedB).setMetadata('last_updated_timestamp',Date.now()).build();const success=this.thoughtStore.updateThought(curr,updatedT);if(!success)logger.warn(`Failed update belief ${activeT.id}(conflict?).`);return success}
    async _checkParentCompletion(activeT,args){if(args.length!==2||!(args[0]instanceof Atom)||!(args[1]instanceof Atom))throw Error("Inv args check_parent_completion");const sDoneName=args[0].name.toUpperCase();const sFailName=args[1].name.toUpperCase();const sDone=Status[sDoneName];const sFail=Status[sFailName];if(!sDone||sDone===Status.ACTIVE||sDone===Status.PENDING)throw Error(`Inv StatusIfDone:${sDoneName}`);if(!sFail||sFail===Status.ACTIVE||sFail===Status.PENDING)throw Error(`Inv StatusIfFail:${sFailName}`);const pId=activeT.metadata?.parent_id;if(!pId)return true;const parent=this.thoughtStore.getThought(pId);if(!parent){logger.warn(`Parent ${pId} not found child ${activeT.id}.`);return true} if(parent.status!==Status.WAITING_CHILDREN)return true;const children=this.thoughtStore.findThoughtsByParentId(pId);if(children.length===0){logger.warn(`Parent ${pId} WAITING but no children. Setting FAILED.`);const fp=parent.toBuilder().setStatus(sFail).setBelief(parent.belief.update(false)).setMetadata('error_info','Waiting no children found.').build();return this.thoughtStore.updateThought(parent,fp)} const anyNonTerm=children.some(c=>c.status!==Status.DONE&&c.status!==Status.FAILED);if(anyNonTerm)return true;const anyFail=children.some(c=>c.status===Status.FAILED);const finalS=anyFail?sFail:sDone;const beliefSig=!anyFail;logger.info(`All children of ${pId} terminal.${anyFail?'Some FAILED.':'All DONE.'} Setting parent status ${finalS}.`);const updatedP=parent.toBuilder().setStatus(finalS).setBelief(parent.belief.update(beliefSig)).build();const success=this.thoughtStore.updateThought(parent,updatedP);if(!success)logger.warn(`Failed update parent ${pId} completion check(conflict?).`);return success}
    async _generateThoughts(activeT,args){if(args.length!==1||!(args[0]instanceof TermBase))throw Error("Inv args generate_thoughts");const promptTerm=args[0];const promptInput=promptTerm.toString();logger.debug(`Calling ThoughtGenerator parent ${activeT.id} prompt:${promptInput.substring(0,150)}...`);try{const newThoughts=await this.thoughtGenerator.generate(promptInput,activeT.id);if(!Array.isArray(newThoughts)){logger.error("ThoughtGen not return array.");return false} if(newThoughts.length>0){logger.info(`ThoughtGen created ${newThoughts.length} thoughts for ${activeT.id}.`);newThoughts.forEach(t=>{if(t instanceof Thought)this.thoughtStore.addThought(t);else logger.warn("ThoughtGen returned non-Thought:",t)})}else{logger.info(`ThoughtGen produced no thoughts for:${promptInput}`)} return true}catch(e){logger.error(`Error during generate_thoughts prim for ${activeT.id}:${e.message}`);return false}}
    async _sequence(activeT,args,subMap){if(args.length!==1||!(args[0]instanceof ListTerm))throw Error("Inv args sequence");const actList=args[0].elements;logger.debug(`Executing sequence ${actList.length} actions for ${activeT.id}`);for(let i=0;i<actList.length;i++){const actTerm=actList[i];if(!(actTerm instanceof Structure))throw Error(`Item ${i} seq not action Struct:${actTerm.toString()}`);const actName=actTerm.name;const actArgs=actTerm.args;const actMeth=this.primitiveActions[actName];if(!actMeth)throw Error(`Unk action "${actName}" seq(item ${i})`);const currActiveState=this.thoughtStore.getThought(activeT.id);if(!currActiveState){logger.warn(`Active thought ${activeT.id} disappeared during seq(before ${i}:${actName}). Aborting.`);return false} if(currActiveState.status!==Status.ACTIVE){logger.info(`Active thought ${activeT.id} status ${currActiveState.status} during seq(before ${i}:${actName}). Stopping.`);return true} logger.debug(`Seq action ${i+1}/${actList.length}:${actName}`);try{const success=await actMeth(currActiveState,actArgs,subMap);if(!success){logger.warn(`Action "${actName}"(item ${i}) failed seq for ${activeT.id}. Aborting.`);return false}}catch(e){logger.error(`Error action "${actName}"(item ${i}) within seq for ${activeT.id}:${e.message}. Aborting.`);throw e}} logger.debug(`Sequence OK for ${activeT.id}`);return true}
    async _callLlm(activeT,args){if(args.length!==2||!(args[0]instanceof TermBase)||!(args[1]instanceof Atom))throw Error("Inv args call_llm");const promptTerm=args[0];const resRoleName=args[1].name.toUpperCase();const resRole=Role[resRoleName];if(!resRole)throw Error(`Inv result role call_llm:${resRoleName}`);if(resRole!==Role.OUTCOME)logger.warn(`call_llm unusual result role:${resRoleName}. Expected OUTCOME.`);const promptStr=promptTerm.toString();logger.debug(`Calling LLM for ${activeT.id}(res role ${resRoleName}). Prompt:"${promptStr.substring(0,100)}..."`);try{const llmRes=await this.llmService.invoke(promptStr);if(!llmRes?.trim()){logger.warn(`LLM call for ${activeT.id} empty resp.`);return true} const resContent=S("llm_response",A(llmRes));const newT=new Thought(generateUUID(),resRole,resContent,Belief.DEFAULT_POSITIVE,Status.PENDING,{parent_id:activeT.id,creation_timestamp:Date.now(),last_updated_timestamp:Date.now(),prompt:promptStr.substring(0,500)});this.thoughtStore.addThought(newT);logger.info(`LLM call OK for ${activeT.id}. Created result ${newT.id} role ${resRoleName}.`);return true}catch(e){logger.error(`call_llm prim failed for ${activeT.id}:${e.message}`);return false}}
    async _logMessage(activeT,args){if(args.length!==2||!(args[0]instanceof Atom)||!(args[1]instanceof TermBase))throw Error("Inv args log_message");const level=args[0].name.toLowerCase();const msgTerm=args[1];const msg=msgTerm.toString();const logFn=logger[level];if(typeof logFn==='function')logFn(`[Action Log - T ${activeT.id}]:${msg}`);else{logger.warn(`Inv log level:${level}. Default info.`);logger.info(`[Action Log - T ${activeT.id}]:${msg}`)} return true}
    async _noOp(activeT,args){if(args.length!==0)throw Error("no_op expects 0 args.");logger.debug(`Executing no_op for ${activeT.id}.`);return true} }

class ThoughtGenerator {
    constructor(ls){this.llmService=ls}
    async generate(promptInput,parentId){
        const fullPrompt=`Given the high-level goal or request "${promptInput}", break it down into a list of specific, actionable sub-tasks or strategies needed to achieve it. Output ONLY a valid JSON list of strings, where each string is a clear sub-task. Example: ["Sub-task 1 description", "Sub-task 2 description"]. If the input is already a simple task or cannot be broken down, return an empty list []. Do not include any other text, explanation, or formatting.`;
        let llmRes; try{llmRes=await this.llmService.invoke(fullPrompt)}catch(e){throw Error(`LLM call failed thought gen:${e.message}`)}
        let tasks=[]; try{tasks=JSON.parse(llmRes);if(!Array.isArray(tasks))throw Error("LLM resp not JSON arr.");if(!tasks.every(t=>typeof t==='string'))throw Error("LLM resp arr non-strings.");tasks=tasks.map(t=>t.trim()).filter(t=>t.length>0)}catch(e){logger.warn(`Failed parse LLM gen resp JSON list:${e.message}. Resp:"${llmRes}"`);throw Error(`LLM resp parsing failed:${e.message}`)}
        if(tasks.length===0){logger.info(`LLM gen no sub-tasks parent ${parentId} prompt:"${promptInput}"`);return[]}
        // *** CORRECTED STRUCTURE CREATION ***
        return tasks.map(taskStr => new Thought(generateUUID(),Role.STRATEGY,
            // Use direct constructor call, ensuring args is an array of Terms
            new Structure("task", [new Atom(taskStr)]),
            Belief.DEFAULT_POSITIVE,Status.PENDING,{parent_id:parentId,creation_timestamp:Date.now(),last_updated_timestamp:Date.now(),source_prompt:promptInput.substring(0,500)}))
    }
}

// === Bootstrap META_THOUGHTs ===
const S=(n,...a)=>new Structure(n,a);const A=(n)=>new Atom(n);const V=(n)=>new Variable(n);const L=(...e)=>new ListTerm(e);
// Corrected templates using direct Atom/Variable arguments for S() helper
const bootstrapMetaThoughtTemplates = [
    { // MT-NOTE-TO-GOAL
        content: S("meta_def",
            // *** CORRECTED TARGET: Use V("Content") not A("Content") ***
            S("user_input", V("Content")),
            // Action sequence
            S("sequence", L(
                S("log_message", A("info"), A("Converting user NOTE to GOAL")),
                S("add_thought", A(Role.GOAL), S("goal_content", V("Content")), A("POSITIVE")), // Action uses V("Content") correctly
                S("set_status", A(Status.DONE))
            ))
        ),
        belief: Belief.DEFAULT_POSITIVE,
        metadata: { description: "Convert user_input NOTE to GOAL" }
    },
    { // MT-GOAL-DECOMPOSE
        content: S("meta_def",
            S("goal_content", V("GoalContent")), // Target uses V("GoalContent")
            S("sequence", L(
                S("log_message", A("info"), S("concat", L(A("Decomposing GOAL: "), V("GoalContent")))),
                S("generate_thoughts", V("GoalContent")), // Action uses V("GoalContent")
                S("set_status", A(Status.WAITING_CHILDREN))
            ))
        ),
        belief: new Belief(1.0, 0.25),
        metadata: { description: "Decompose GOAL into STRATEGIES", applicable_role: Role.GOAL }
    },
    { // MT-STRATEGY-EXECUTE
        content: S("meta_def",
            S("task", V("TaskDesc")), // Target uses V("TaskDesc")
            S("sequence", L(
                S("log_message", A("info"), S("concat", L(A("Executing STRATEGY: "), V("TaskDesc")))),
                S("call_llm", S("execute_task_prompt", V("TaskDesc")), A(Role.OUTCOME)), // Action uses V("TaskDesc")
                S("set_status", A(Status.DONE))
            ))
        ),
        belief: Belief.DEFAULT_POSITIVE,
        metadata: { description: "Execute task STRATEGY via LLM", applicable_role: Role.STRATEGY }
    },
    { // MT-OUTCOME-PROCESS
        content: S("meta_def",
            S("llm_response", V("Result")), // Target uses V("Result")
            S("sequence", L(
                S("log_message", A("debug"), S("concat", L(A("Processing OUTCOME: "), V("Result")))),
                S("set_belief", A("POSITIVE")),
                S("set_status", A(Status.DONE)),
                S("check_parent_completion", A(Status.DONE), A(Status.FAILED))
            ))
        ),
        belief: Belief.DEFAULT_POSITIVE,
        metadata: { description: "Process llm_response OUTCOME, check parent", applicable_role: Role.OUTCOME }
    },
].filter(t => t.content instanceof Structure && t.content.name === 'meta_def');

// === Garbage Collection ===
function garbageCollect(ts){logger.info("Running GC...");const start=Date.now();const thresh=start-config.gcThresholdMillis;let removed=0;let examined=0;const allT=ts.getAllThoughts();const tIndex=new Map(allT.map(t=>[t.id,t]));const childrenMap=new Map();for(const t of allT){examined++;const pId=t.metadata?.parent_id;if(pId){const ch=childrenMap.get(pId)||[];ch.push(t.id);childrenMap.set(pId,ch)}} for(let i=allT.length-1;i>=0;i--){const t=allT[i];const isTerm=t.status===Status.DONE||t.status===Status.FAILED;const ts=t.metadata?.last_updated_timestamp??t.metadata?.creation_timestamp??0;const isOld=ts<thresh;if(isTerm&&isOld){const childIds=childrenMap.get(t.id)||[];const hasActive=childIds.some(cId=>{const c=tIndex.get(cId);return c&&c.status!==Status.DONE&&c.status!==Status.FAILED});if(hasActive){logger.debug(`GC:Skip ${t.id}(${t.status}) due active children.`);continue} if(ts.removeThought(t.id))removed++}} const dur=Date.now()-start;logger.info(`GC complete.Examined ${examined},removed ${removed} in ${dur}ms.`)}

// === ExecuteLoop ===
class ExecuteLoop { constructor(ts,un,ae){this.thoughtStore=ts;this.unifier=un;this.actionExecutor=ae;this.isRunning=false;this.timeoutId=null;this.activeThoughtProcessing=null} start(){if(this.isRunning)return;this.isRunning=true;logger.info("Starting Coglog ExecuteLoop...");this.scheduleNextCycle(0)} async stop(){if(!this.isRunning)return;this.isRunning=false;if(this.timeoutId)clearTimeout(this.timeoutId);this.timeoutId=null;logger.info("ExecuteLoop stopping...");if(this.activeThoughtProcessing){logger.info("Waiting current cycle...");try{await this.activeThoughtProcessing;logger.info("Current cycle finished.")}catch(e){logger.warn("Err final cycle:",e?.message)}} this.activeThoughtProcessing=null;logger.info("ExecuteLoop stopped.")} scheduleNextCycle(delay=config.pollIntervalMillis){if(!this.isRunning)return;if(this.timeoutId)clearTimeout(this.timeoutId);this.timeoutId=setTimeout(()=>{setImmediate(async()=>{if(!this.isRunning)return;this.activeThoughtProcessing=this.runCycle();try{await this.activeThoughtProcessing}catch(e){logger.error("!!! Unhandled err escaped cycle:",e)}finally{this.activeThoughtProcessing=null;if(this.isRunning){const counts=this.thoughtStore.getStatusCounts();const nextDelay=counts.PENDING>0?0:config.pollIntervalMillis;this.scheduleNextCycle(nextDelay)}}})},delay)}
    async runCycle(){let activeTStart=null;try{const pendingT=this.thoughtStore.samplePendingThought();if(!pendingT){logger.debug("No PENDING found.");return} const currState=this.thoughtStore.getThought(pendingT.id);if(!currState){logger.warn(`Sampled PENDING ${pendingT.id} disappeared.`);return} if(currState.status!==Status.PENDING){logger.debug(`Thought ${currState.id} status ${currState.status}. Resampling.`);return} activeTStart=currState;const activatedT=activeTStart.toBuilder().setStatus(Status.ACTIVE).setMetadata('last_updated_timestamp',Date.now()).build();if(!this.thoughtStore.updateThought(activeTStart,activatedT)){logger.warn(`Failed set ${activeTStart.id} ACTIVE (conflict?). Resched.`);return} const processingT=activatedT;logger.info(`Processing ${processingT.id} (Role:${processingT.role}, Content:${processingT.content.toString().substring(0,80)}...)`);let timeoutId=null;const timeoutP=new Promise((_,reject)=>{timeoutId=setTimeout(()=>{const e=new Error(`Exec timeout(>${config.maxActiveDurationMillis}ms)`);e.name='TimeoutError';reject(e)},config.maxActiveDurationMillis)});try{await Promise.race([(async()=>{const metas=this.thoughtStore.getMetaThoughts();const uniRes=this.unifier.findAndSampleMatchingMeta(processingT,metas);if(uniRes.hasMatch){const{matchedMetaThought:metaT,substitutionMap:subMap}=uniRes;const actSuccess=await this.actionExecutor.execute(processingT,metaT,subMap);const finalState=this.thoughtStore.getThought(processingT.id);if(!finalState){logger.warn(`Thought ${processingT.id} disappeared during action.`)}else if(actSuccess&&finalState.status===Status.ACTIVE){logger.warn(`Action ${processingT.id} OK but no terminal status. Marking FAILED.`);this.handleFailure(finalState,"Action did not set terminal status",0)}else if(!actSuccess&&finalState.status===Status.ACTIVE){logger.warn(`Action ${processingT.id} failed, marking FAILED.`);this.handleFailure(finalState,"Action execution reported failure",this.calculateRemainingRetries(finalState))}}else{logger.warn(`No matching META for ${processingT.id}. Marking FAILED.`);this.handleFailure(processingT,"No matching META_THOUGHT",0)}})(),timeoutP])}catch(e){const stateAfterErr=this.thoughtStore.getThought(processingT.id);if(!stateAfterErr){logger.warn(`Thought ${processingT.id} disappeared after error:${e.message}`)}else if(stateAfterErr.status===Status.ACTIVE){if(e.name==='TimeoutError'){logger.warn(`Timeout processing ${processingT.id}.`);this.handleFailure(stateAfterErr,"Timeout during action execution",this.calculateRemainingRetries(stateAfterErr))}else{logger.error(`Error processing ${processingT.id}:`,e);this.handleFailure(stateAfterErr,`Execution Error:${e.message}`,this.calculateRemainingRetries(stateAfterErr))}}else{logger.warn(`Error occurred for ${processingT.id} but status already ${stateAfterErr.status}. Error:${e.message}`)}}finally{if(timeoutId)clearTimeout(timeoutId)}}catch(cycleErr){logger.error("!!! Critical err cycle logic:",cycleErr);if(activeTStart){const state=this.thoughtStore.getThought(activeTStart.id);if(state&&(state.status===Status.ACTIVE||state.status===Status.PENDING)){const tFail=state.status===Status.ACTIVE?state:activeTStart;logger.error(`Marking ${tFail.id} FAILED due unhandled cycle err.`);this.handleFailure(tFail,`Unhandled cycle error:${cycleErr.message}`,0)}} throw cycleErr}}
    handleFailure(tFail,errMsg,retriesLeft){const curr=this.thoughtStore.getThought(tFail.id);if(!curr){logger.warn(`Thought ${tFail.id} not found failure handling.`);return} if(curr.status!==Status.ACTIVE){logger.debug(`Thought ${curr.id} status ${curr.status}, not ACTIVE. Skip failure handling for:${errMsg}`);return} const retryCount=(curr.metadata?.retry_count||0)+1;const newS=retriesLeft>0?Status.PENDING:Status.FAILED;const updatedB=curr.belief.update(false);logger.warn(`Handling failure ${curr.id}:"${errMsg}". Retries left:${retriesLeft}. New status:${newS}.`);const updatedT=curr.toBuilder().setStatus(newS).setBelief(updatedB).setMetadata('error_info',errMsg.substring(0,1000)).setMetadata('retry_count',retryCount).build();if(!this.thoughtStore.updateThought(curr,updatedT)){logger.error(`Failed update ${curr.id} to ${newS} during failure handling (conflict?)!`)}}
    calculateRemainingRetries(t){const retries=t.metadata?.retry_count||0;const effRetries=Math.min(retries,config.maxRetries);return Math.max(0,config.maxRetries-effRetries)} }

// === Initialization and Main Execution ===
async function main(){logger.info("--- Coglog 2.6.1 Initializing ---");const ps=new PersistenceService(config.persistenceFile);const sn=new StoreNotifier();const ls=new LlmService();const tp=new TextParserService();const ts=new ThoughtStore(ps,sn);const tg=new ThoughtGenerator(ls);const un=new Unifier();const ae=new ActionExecutor(ts,tg,ls);const el=new ExecuteLoop(ts,un,ae);await ts.loadState();let initialCount=ts.thoughts.size;
    if(initialCount===0){logger.info("Loading bootstrap META...");bootstrapMetaThoughtTemplates.forEach(tmpl=>{const metaT=new Thought(generateUUID(),Role.META_THOUGHT,tmpl.content,tmpl.belief,Status.PENDING,{...(tmpl.metadata||{}),is_bootstrap:true,creation_timestamp:Date.now(),last_updated_timestamp:Date.now()});ts.addThought(metaT)});logger.info(`Loaded ${ts.thoughts.size} bootstrap META.`);const initialNote=tp.parse("Create plan for today's top 3 priorities.");if(initialNote)ts.addThought(initialNote);logger.info("Added sample initial NOTE.");initialCount=ts.thoughts.size}
    else{logger.info(`Loaded ${initialCount} thoughts.`);let resetCount=0;const toReset=[];for(const t of ts.getAllThoughts()){if(t.status===Status.ACTIVE)toReset.push(t)} toReset.forEach(t=>{const curr=ts.getThought(t.id);if(curr&&curr.status===Status.ACTIVE){const resetT=curr.toBuilder().setStatus(Status.PENDING).setMetadata('error_info','Reset PENDING restart').build();if(ts.updateThought(curr,resetT))resetCount++;else logger.warn(`Failed reset ${t.id} ACTIVE->PENDING(conflict?).`)}});if(resetCount>0)logger.info(`Reset ${resetCount} ACTIVE thoughts to PENDING.`)}
    logger.info("Scheduling initial GC...");setTimeout(()=>garbageCollect(ts),5000);const gcId=setInterval(()=>garbageCollect(ts),config.gcIntervalMillis);logger.info(`GC scheduled every ${config.gcIntervalMillis/1000/60} mins.`);el.start();logger.info(`Engine started. Initial thoughts:${initialCount}. Status:${JSON.stringify(ts.getStatusCounts())}`);
    const shutdown=async(sig)=>{logger.info(`${sig} received. Shutting down...`);await el.stop();clearInterval(gcId);logger.info("Stopped periodic GC.");if(ts._savingPromise||ts._saveQueued){logger.info("Waiting final persistence...");if(!ts._savingPromise&&ts._saveQueued)await ts.persistState();while(ts._savingPromise)await ts._savingPromise;logger.info("Final persistence complete.")}else{logger.info("Triggering final save.");try{await ts.persistenceService.save(ts.thoughts);logger.info("Final state saved.")}catch(e){logger.error("Err final save:",e)}} logger.info("Coglog shutdown complete.");process.exit(0)};
    process.on('SIGINT',()=>shutdown('SIGINT'));process.on('SIGTERM',()=>shutdown('SIGTERM'));logger.info("--- Coglog Init Complete ---");logger.info("Press Ctrl+C to exit.");}

main().catch(e=>{console.error("!!! Unhandled exception startup/shutdown:",e);process.exit(1)});