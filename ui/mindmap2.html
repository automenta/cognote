<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
    <title>NeuroWeaver 🧠 v2</title>
    <link href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🧠</text></svg>"
          rel="icon">
    <style>
        :root {
            --bg-color: #10101a;
            --primary-color: #e8e8ff;
            --accent-color: #00f7ff;
            --accent-color-darker: #00a0a8;
            --node-bg: rgba(26, 26, 46, 0.9);
            --node-border: var(--accent-color-darker);
            --node-shadow: rgba(0, 247, 255, 0.15);
            --node-hover-shadow: rgba(0, 247, 255, 0.4);
            --edge-color: rgba(0, 247, 255, 0.6);
            --edge-hover-color: rgba(0, 247, 255, 1);
            --edge-ghost-color: rgba(0, 247, 255, 0.2);
            --delete-button-bg: #ff3d3d;
            --delete-button-text: #ffffff;
            --menu-bg: rgba(30, 30, 50, 0.97);
            --menu-border: var(--accent-color);
            --menu-hover-bg: rgba(0, 247, 255, 0.15);
            --dialog-bg: rgba(35, 35, 60, 0.98);
            --font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            --font-mono: 'Fira Code', 'Consolas', 'Monaco', monospace;
            --transition-fast: 0.15s ease-out;
            --transition-med: 0.3s ease-out;
        }

        *, *::before, *::after { box-sizing: border-box; }

        body {
            margin: 0; overflow: hidden; background-color: var(--bg-color); color: var(--primary-color);
            font-family: var(--font-family); font-size: 14px; overscroll-behavior: none;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
        }

        #mindmap-container { position: fixed; inset: 0; cursor: grab; }
        #mindmap-container.panning { cursor: grabbing; }
        #mindmap-container.linking { cursor: crosshair; }

        #webgl-canvas, #css3d-container { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
        #webgl-canvas { z-index: 1; }
        #css3d-container { z-index: 2; pointer-events: none; }

        .node-html {
            position: absolute; background-color: var(--node-bg); border: 1px solid var(--node-border);
            border-radius: 8px; padding: 12px 15px; color: var(--primary-color); pointer-events: auto;
            cursor: grab; transition: transform var(--transition-fast), box-shadow var(--transition-med), border-color var(--transition-med);
            box-shadow: 0 2px 10px 2px var(--node-shadow); min-width: 80px; min-height: 40px;
            display: flex; flex-direction: column; overflow: hidden; backdrop-filter: blur(5px); user-select: none;
        }
        .node-html:hover { box-shadow: 0 4px 20px 5px var(--node-hover-shadow); border-color: var(--accent-color); z-index: 10 !important; }
        .node-html.dragging { cursor: grabbing; box-shadow: 0 10px 30px 8px var(--node-hover-shadow); z-index: 1000 !important; transition: none; }
        .node-html.resizing { transition: none; }
        .node-html.linking-target { border-color: #ffaa00; box-shadow: 0 0 25px 5px rgba(255, 170, 0, 0.6); }

        .node-content { flex-grow: 1; outline: none; overflow-y: auto; max-height: 400px; font-size: 1em; line-height: 1.45; white-space: pre-wrap; word-wrap: break-word; user-select: text; scrollbar-width: thin; scrollbar-color: var(--accent-color-darker) transparent; }
        .node-content::-webkit-scrollbar { width: 6px; }
        .node-content::-webkit-scrollbar-track { background: transparent; }
        .node-content::-webkit-scrollbar-thumb { background-color: var(--accent-color-darker); border-radius: 3px; }
        .node-content:focus { box-shadow: inset 0 0 0 1px var(--accent-color); margin: -1px; }
        .node-content > *:first-child { margin-top: 0; } .node-content > *:last-child { margin-bottom: 0; }
        .node-content h1, .node-content h2, .node-content h3 { margin: 0.5em 0; color: var(--accent-color); font-weight: 600; }
        .node-content h1 { font-size: 1.3em; } .node-content h2 { font-size: 1.15em; } .node-content h3 { font-size: 1.05em; }
        .node-content p { margin: 0.5em 0; } .node-content ul, .node-content ol { margin: 0.5em 0; padding-left: 20px; } .node-content li { margin-bottom: 0.2em; }
        .node-content code { font-family: var(--font-mono); background-color: rgba(0,0,0,0.2); padding: 0.1em 0.3em; border-radius: 3px; font-size: 0.9em; }
        .node-content pre { font-family: var(--font-mono); background-color: rgba(0,0,0,0.2); padding: 0.5em; border-radius: 4px; overflow-x: auto; font-size: 0.9em; }
        .node-content blockquote { border-left: 3px solid var(--accent-color-darker); margin: 0.5em 0 0.5em 10px; padding-left: 10px; color: #bbb; }
        .node-content a { color: var(--accent-color); text-decoration: none; } .node-content a:hover { text-decoration: underline; }

        .node-controls { position: absolute; top: -12px; right: -12px; display: flex; gap: 4px; opacity: 0; transition: opacity var(--transition-fast); pointer-events: none; z-index: 15; }
        .node-html:hover .node-controls { opacity: 0.8; pointer-events: auto; }
        .node-controls button { pointer-events: auto; background: var(--accent-color-darker); color: var(--primary-color); border: none; border-radius: 50%; width: 24px; height: 24px; font-size: 14px; line-height: 24px; text-align: center; cursor: pointer; box-shadow: 0 1px 5px rgba(0,0,0,0.4); transition: background-color var(--transition-fast), transform var(--transition-fast); }
        .node-controls button:hover { background: var(--accent-color); color: var(--bg-color); transform: scale(1.15); }
        .node-controls .node-delete { background-color: var(--delete-button-bg); color: var(--delete-button-text); font-weight: bold; font-size: 16px; }
        .node-controls .node-delete:hover { background-color: #ff6666; }

        .node-quick-controls { position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%); display: flex; gap: 4px; opacity: 0; transition: opacity var(--transition-fast); pointer-events: none; z-index: 15; }
        .node-html:hover .node-quick-controls { opacity: 0.8; pointer-events: auto; }
        .node-quick-controls button { pointer-events: auto; background: rgba(0,0,0,0.5); backdrop-filter: blur(3px); color: var(--primary-color); border: 1px solid var(--accent-color-darker); border-radius: 4px; width: 24px; height: 20px; font-size: 12px; line-height: 18px; text-align: center; cursor: pointer; transition: background-color var(--transition-fast), border-color var(--transition-fast), transform var(--transition-fast); }
        .node-quick-controls button:hover { background: var(--accent-color-darker); border-color: var(--accent-color); transform: scale(1.1); }
        .node-quick-controls .text-zoom-label, .scale-label { font-size: 10px; color: var(--accent-color-darker); margin: 0 3px; line-height: 20px; }

        .resize-handle { position: absolute; bottom: -8px; right: -8px; width: 16px; height: 16px; background-color: var(--accent-color); border: 1px solid var(--bg-color); border-radius: 3px; cursor: nwse-resize; box-shadow: 0 1px 5px rgba(0,0,0,0.4); opacity: 0; transition: opacity var(--transition-fast), transform var(--transition-fast); pointer-events: auto; z-index: 10; }
        .node-html:hover .resize-handle { opacity: 0.7; }
        .resize-handle:hover { opacity: 1; transform: scale(1.15); }

        .context-menu, .dialog { position: fixed; background-color: var(--menu-bg); border: 1px solid var(--menu-border); border-radius: 6px; box-shadow: 0 5px 25px rgba(0, 0, 0, 0.6); z-index: 10000; display: none; backdrop-filter: blur(8px); animation: fadeIn 0.1s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        .context-menu { padding: 6px 0; min-width: 160px; }
        .context-menu ul { list-style: none; padding: 0; margin: 0; }
        .context-menu li { padding: 8px 18px; cursor: pointer; transition: background-color var(--transition-fast), color var(--transition-fast); color: var(--primary-color); white-space: nowrap; }
        .context-menu li:hover { background-color: var(--menu-hover-bg); color: var(--accent-color); }
        .context-menu li.disabled { color: #777; cursor: default; background-color: transparent !important; }
        .context-menu li[data-action^="delete"] { color: var(--delete-button-bg); }
        .context-menu li[data-action^="delete"]:hover { background-color: rgba(255, 61, 61, 0.2); }
        .context-menu hr { border: none; border-top: 1px solid var(--accent-color-darker); margin: 4px 0; }

        .dialog { top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: var(--dialog-bg); padding: 25px 30px; text-align: center; color: var(--primary-color); min-width: 300px; }
        .dialog p { margin: 0 0 25px 0; font-size: 1.1em; }
        .dialog button { background-color: var(--accent-color); color: var(--bg-color); border: none; padding: 10px 22px; margin: 0 10px; border-radius: 5px; cursor: pointer; font-weight: 600; transition: background-color var(--transition-fast), box-shadow var(--transition-fast); min-width: 80px; }
        .dialog button:hover { background-color: #3fffff; box-shadow: 0 0 12px var(--accent-color); }
        .dialog button#confirm-no { background-color: #555; color: var(--primary-color); }
        .dialog button#confirm-no:hover { background-color: #777; box-shadow: none; }

        #status-indicator { position: fixed; bottom: 10px; left: 10px; background-color: rgba(0, 0, 0, 0.6); color: var(--primary-color); padding: 5px 12px; border-radius: 4px; font-size: 12px; z-index: 5; opacity: 1; transition: opacity 0.5s ease 1s; pointer-events: none; }
        #status-indicator.hidden { opacity: 0; }

        body::before { content: ''; position: fixed; inset: 0; background-image: radial-gradient(rgba(0, 247, 255, 0.03) 1px, transparent 1px); background-size: 20px 20px; opacity: 0.5; z-index: 0; pointer-events: none; }

        /* Animated Node Style */
        .pulsing-node .node-content::before {
            content: ''; position: absolute; inset: -2px; border: 2px solid var(--accent-color); border-radius: 8px;
            opacity: 0; animation: pulse 2.5s infinite ease-out; pointer-events: none;
        }
        @keyframes pulse { 0%, 100% { opacity: 0; transform: scale(0.95); } 50% { opacity: 0.6; transform: scale(1.05); } }
    </style>
</head>
<body>
<div id="mindmap-container">
    <canvas id="webgl-canvas"></canvas>
    <div id="css3d-container"></div>
</div>

<div class="context-menu" id="context-menu"></div>
<div class="dialog" id="confirm-dialog">
    <p id="confirm-message">Are you sure?</p>
    <button id="confirm-yes">Yes</button>
    <button id="confirm-no">No</button>
</div>
<div id="status-indicator">Initializing NeuroWeaver...</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/",
            "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
    import { gsap } from "gsap";

    const $ = (selector) => document.querySelector(selector);
    const $$ = (selector) => document.querySelectorAll(selector);

    const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
    const lerp = (a, b, t) => a + (b - a) * t;
    const generateId = (prefix) => `${prefix}-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 7)}`;
    const getCSSVar = (varName) => getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    const hexToRgb = (hex) => { const bigint = parseInt(hex.startsWith('#') ? hex.slice(1) : hex, 16); return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 }; };

    const EDGE_COLORS = {
        default: new THREE.Color(getCSSVar('--edge-color')),
        hover: new THREE.Color(getCSSVar('--edge-hover-color')),
        ghost: new THREE.Color(getCSSVar('--edge-ghost-color')),
    };

    class MindMap {
        nodes = new Map();
        edges = new Map();
        isDraggingNode = false;
        isResizingNode = false;
        isLinking = false;
        linkSourceNode = null;
        tempLinkLine = null;
        uiManager = null;
        cameraController = null;
        layoutEngine = null;
        selectedEdge = null;

        constructor(container) {
            this.container = container;
            this.scene = new THREE.Scene();
            this.cssScene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 10, 20000);
            this.camera.position.z = 600;

            this.webglRenderer = new THREE.WebGLRenderer({ canvas: $('#webgl-canvas'), antialias: true, alpha: true });
            this.webglRenderer.setSize(window.innerWidth, window.innerHeight);
            this.webglRenderer.setPixelRatio(window.devicePixelRatio);

            this.cssRenderer = new CSS3DRenderer();
            this.cssRenderer.setSize(window.innerWidth, window.innerHeight);
            $('#css3d-container').appendChild(this.cssRenderer.domElement);

            this.scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(0.5, 1, 0.75);
            this.scene.add(directionalLight);

            window.addEventListener('resize', this.onWindowResize.bind(this), false);
        }

        addNode(node) {
            if (!node.id) node.id = generateId('node');
            if (this.nodes.has(node.id)) return this.nodes.get(node.id);
            this.nodes.set(node.id, node);
            node.mindMap = this;
            if (node.threeObject) this.scene.add(node.threeObject);
            if (node.cssObject) this.cssScene.add(node.cssObject);
            this.layoutEngine?.addNode(node);
            return node;
        }

        removeNode(nodeId) {
            const node = this.nodes.get(nodeId);
            if (!node) return;
            [...this.edges.values()].filter(edge => edge.source === node || edge.target === node).forEach(edge => this.removeEdge(edge.id));
            node.dispose();
            this.nodes.delete(nodeId);
            this.layoutEngine?.removeNode(node);
            this.uiManager?.removeNodeHTML(nodeId);
        }

        addEdge(sourceNode, targetNode, data = { style: 'elastic' }) {
            if (!sourceNode || !targetNode || sourceNode === targetNode) return null;
            if ([...this.edges.values()].some(e => (e.source === sourceNode && e.target === targetNode) || (e.source === targetNode && e.target === sourceNode))) return null; // Prevent duplicates

            const edgeId = generateId('edge');
            const edge = new Edge(edgeId, sourceNode, targetNode, data);
            edge.mindMap = this;
            this.edges.set(edgeId, edge);
            if (edge.threeObject) this.scene.add(edge.threeObject);
            this.layoutEngine?.addEdge(edge);
            return edge;
        }

        removeEdge(edgeId) {
            const edge = this.edges.get(edgeId);
            if (!edge) return;
            if (this.selectedEdge === edge) this.selectedEdge = null;
            edge.dispose();
            this.edges.delete(edgeId);
            this.layoutEngine?.removeEdge(edge);
        }

        getNodeById = (id) => this.nodes.get(id);
        getEdgeById = (id) => this.edges.get(id);

        update(time) {
            this.nodes.forEach(node => node.update(time));
            this.edges.forEach(edge => edge.update());
        }

        render() {
            this.webglRenderer.render(this.scene, this.camera);
            this.cssRenderer.render(this.cssScene, this.camera);
        }

        onWindowResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.webglRenderer.setSize(window.innerWidth, window.innerHeight);
            this.cssRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        centerView(targetPosition = null, duration = 0.7) {
            let targetPos;
            if (targetPosition) {
                targetPos = targetPosition.clone();
            } else {
                targetPos = this.nodes.size > 0 ? [...this.nodes.values()].reduce((acc, node) => acc.add(node.position), new THREE.Vector3()).divideScalar(this.nodes.size) : new THREE.Vector3();
            }
            const distance = this.nodes.size > 1 ? 600 : 300;
            this.cameraController?.moveTo(targetPos.x, targetPos.y, targetPos.z + distance, duration, targetPos);
        }

        focusOnNode(node, duration = 0.6) {
            if (!node) return;
            const targetPos = node.position.clone();
            const distance = Math.max(node.size.width, node.size.height) * 1.5 + 150;
            this.cameraController?.moveTo(targetPos.x, targetPos.y, targetPos.z + distance, duration, targetPos);
        }

        getWorldPositionFromScreen(screenX, screenY, targetZ = 0) {
            const vec = new THREE.Vector3((screenX / window.innerWidth) * 2 - 1, -(screenY / window.innerHeight) * 2 + 1, 0.5);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(vec, this.camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -targetZ);
            const intersectPoint = new THREE.Vector3();
            return raycaster.ray.intersectPlane(plane, intersectPoint) ? intersectPoint : null;
        }

        projectToScreen(worldPosition) {
            const vector = worldPosition.clone().project(this.camera);
            return {
                x: Math.round((vector.x + 1) * window.innerWidth / 2),
                y: Math.round((-vector.y + 1) * window.innerHeight / 2)
            };
        }

        findClosestEdge(screenX, screenY, threshold = 15) {
            let closestEdge = null;
            let minDistanceSq = threshold * threshold;

            for (const edge of this.edges.values()) {
                const p1 = this.projectToScreen(edge.source.position);
                const p2 = this.projectToScreen(edge.target.position);
                const p = { x: screenX, y: screenY };

                const l2 = (p1.x - p2.x)**2 + (p1.y - p2.y)**2;
                if (l2 === 0) continue; // Avoid division by zero if points overlap

                let t = ((p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y)) / l2;
                t = Math.max(0, Math.min(1, t)); // Clamp t to the segment

                const closestPoint = { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
                const distSq = (p.x - closestPoint.x)**2 + (p.y - closestPoint.y)**2;

                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    closestEdge = edge;
                }
            }
            return closestEdge;
        }

        setSelectedEdge(edge) {
            if (this.selectedEdge && this.selectedEdge !== edge) {
                this.selectedEdge.setSelected(false);
            }
            this.selectedEdge = edge;
            if (edge) edge.setSelected(true);
        }
    }

    class Node {
        mindMap = null;
        threeObject = null;
        htmlElement = null;
        cssObject = null;
        position = new THREE.Vector3();
        size = { width: 160, height: 70 };
        textZoom = 1.0;
        data = {};

        constructor(id, position = { x: 0, y: 0, z: 0 }, data = {}) {
            this.id = id;
            this.position.set(position.x, position.y, position.z);
            this.data = data;
            this.htmlElement = this._createHtmlElement();
            this.cssObject = new CSS3DObject(this.htmlElement);
            this.update();
        }

        _createHtmlElement() {
            const el = document.createElement('div');
            el.className = 'node-html';
            el.id = `node-html-${this.id}`;
            el.dataset.nodeId = this.id;
            el.style.width = `${this.size.width}px`;
            el.style.height = `${this.size.height}px`;

            el.innerHTML = `
                <div class="node-controls">
                    <button class="node-link" title="Start Link ✨" data-action="start-link">🔗</button>
                    <button class="node-delete" title="Delete Node 🗑️" data-action="delete-node">×</button>
                </div>
                <div class="node-content" spellcheck="false">${this.data.label || ''}</div>
                <div class="node-quick-controls">
                    <span class="text-zoom-label">T</span>
                    <button class="text-zoom-out" title="Zoom Text Out" data-action="text-zoom-out">-</button>
                    <button class="text-zoom-in" title="Zoom Text In" data-action="text-zoom-in">+</button>
                    <span class="scale-label">S</span>
                    <button class="scale-down" title="Shrink Node" data-action="scale-down">-</button>
                    <button class="scale-up" title="Grow Node" data-action="scale-up">+</button>
                </div>
                <div class="resize-handle" title="Resize Node"></div>
            `;
            el.querySelector('.node-content').style.fontSize = `${this.textZoom}em`;
            return el;
        }

        setPosition(x, y, z) { this.position.set(x, y, z); }

        setSize(width, height) {
            this.size.width = Math.max(80, width);
            this.size.height = Math.max(40, height);
            if (this.htmlElement) {
                this.htmlElement.style.width = `${this.size.width}px`;
                this.htmlElement.style.height = `${this.size.height}px`;
            }
            this.mindMap?.layoutEngine?.kick();
        }

        adjustScale(factor) {
            this.setSize(this.size.width * factor, this.size.height * factor);
        }

        adjustTextZoom(delta) {
            this.textZoom = clamp(this.textZoom + delta, 0.5, 3.0);
            const contentEl = this.htmlElement?.querySelector('.node-content');
            if (contentEl) contentEl.style.fontSize = `${this.textZoom}em`;
        }

        update(time) {
            if (this.cssObject) this.cssObject.position.copy(this.position);
        }

        dispose() {
            this.cssObject?.parent?.remove(this.cssObject);
            this.threeObject?.parent?.remove(this.threeObject);
        }

        startDrag() { this.htmlElement?.classList.add('dragging'); this.mindMap?.layoutEngine?.fixNode(this); }
        drag(newPosition) { this.setPosition(newPosition.x, newPosition.y, newPosition.z); this.update(); }
        endDrag() { this.htmlElement?.classList.remove('dragging'); this.mindMap?.layoutEngine?.releaseNode(this); this.mindMap?.layoutEngine?.kick(); }
        startResize() { this.htmlElement?.classList.add('resizing'); this.mindMap?.layoutEngine?.fixNode(this); }
        resize(newWidth, newHeight) { this.setSize(newWidth, newHeight); }
        endResize() { this.htmlElement?.classList.remove('resizing'); this.mindMap?.layoutEngine?.releaseNode(this); }
    }

    class NoteNode extends Node {
        constructor(position = { x: 0, y: 0, z: 0 }, data = { content: '' }) {
            super(generateId('note'), position, { ...data, type: 'note', label: data.content });
            this._setupRichText();
        }

        _setupRichText() {
            this.htmlElement.classList.add('note-node');
            const contentDiv = this.htmlElement.querySelector('.node-content');
            if (contentDiv) {
                contentDiv.contentEditable = "true";
                let debounceTimer;
                contentDiv.addEventListener('input', () => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => { this.data.content = contentDiv.innerHTML; this.data.label = contentDiv.innerHTML; }, 300);
                });
                contentDiv.addEventListener('mousedown', e => e.stopPropagation());
                contentDiv.addEventListener('touchstart', e => e.stopPropagation(), { passive: true });
                contentDiv.addEventListener('wheel', this._handleWheelZoom.bind(this), { passive: false });
            }
        }

        _handleWheelZoom(event) {
            if (event.ctrlKey || event.metaKey) {
                event.preventDefault();
                event.stopPropagation();
                const delta = -event.deltaY * 0.001;
                this.adjustTextZoom(delta * 0.5); // Adjust sensitivity
            }
            // Allow normal scrolling otherwise
        }
    }

    class PulsingNode extends Node {
         constructor(position = { x: 0, y: 0, z: 0 }, data = { label: 'Pulsing Node ✨' }) {
            super(generateId('pulse'), position, { ...data, type: 'pulsing' });
            this.htmlElement.classList.add('pulsing-node');
            this.htmlElement.style.borderColor = 'transparent'; // Hide default border for pulse effect
        }

        // Optional: Add WebGL pulsing effect if needed
    }

    class Edge {
        mindMap = null;
        threeObject = null;
        isSelected = false;

        constructor(id, sourceNode, targetNode, data = { style: 'elastic' }) {
            this.id = id;
            this.source = sourceNode;
            this.target = targetNode;
            this.data = data;
            this.threeObject = this._createThreeObject();
            this.update();
            this.updateStyle();
        }

        _createThreeObject() {
            const material = new THREE.LineBasicMaterial({
                linewidth: 2, // Note: limited support, consider Line2 for width control
                vertexColors: false, // Use single color
                transparent: true,
                depthTest: false, // Render edges on top slightly
            });
            const points = [this.source.position.clone(), this.target.position.clone()];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            line.renderOrder = -1;
            line.userData.edgeId = this.id; // Link back to edge object
            return line;
        }

        update() {
            if (!this.threeObject || !this.source || !this.target) return;
            const positions = this.threeObject.geometry.attributes.position;
            positions.setXYZ(0, this.source.position.x, this.source.position.y, this.source.position.z);
            positions.setXYZ(1, this.target.position.x, this.target.position.y, this.target.position.z);
            positions.needsUpdate = true;
            this.threeObject.geometry.computeBoundingSphere();
        }

        updateStyle() {
            if (!this.threeObject) return;
            const material = this.threeObject.material;
            const style = this.data.style || 'elastic'; // Default to elastic

            material.color = this.isSelected ? EDGE_COLORS.hover : (style === 'ghost' ? EDGE_COLORS.ghost : EDGE_COLORS.default);
            material.opacity = style === 'ghost' ? 0.3 : (this.isSelected ? 1.0 : 0.6);
            material.needsUpdate = true;
            // Note: LineDashedMaterial requires computeLineDistances() and different setup if needed
        }

        setSelected(selected) {
            if (this.isSelected === selected) return;
            this.isSelected = selected;
            this.updateStyle();
        }

        setStyle(newStyle) {
            if (['elastic', 'rigid', 'ghost'].includes(newStyle)) {
                this.data.style = newStyle;
                this.updateStyle();
                this.mindMap?.layoutEngine?.kick(); // Nudge layout if style affects forces
            }
        }

        dispose() {
            if (this.threeObject?.parent) {
                this.threeObject.parent.remove(this.threeObject);
                this.threeObject.geometry?.dispose();
                this.threeObject.material?.dispose();
            }
        }
    }

    class UIManager {
        draggedNode = null;
        resizedNode = null;
        resizeStartPos = { x: 0, y: 0 };
        resizeStartSize = { width: 0, height: 0 };
        dragOffset = new THREE.Vector3();
        isMouseDown = false;
        potentialClick = true;
        lastPointerPos = { x: 0, y: 0 };
        confirmCallback = null;

        constructor(mindMap) {
            this.mindMap = mindMap;
            this.container = mindMap.container;
            this.cssContainer = mindMap.cssRenderer.domElement;
            this.contextMenu = $('#context-menu');
            this.confirmDialog = $('#confirm-dialog');
            this._bindEvents();
        }

        _bindEvents() {
            this.container.addEventListener('pointerdown', this.onPointerDown.bind(this));
            window.addEventListener('pointermove', this.onPointerMove.bind(this));
            window.addEventListener('pointerup', this.onPointerUp.bind(this));
            this.container.addEventListener('contextmenu', this.onContextMenu.bind(this));
            document.addEventListener('click', (e) => { if (!this.contextMenu.contains(e.target)) this.hideContextMenu(); }, true);
            this.contextMenu.addEventListener('click', this.onMenuClick.bind(this));
            $('#confirm-yes').addEventListener('click', this.onConfirmYes.bind(this));
            $('#confirm-no').addEventListener('click', this.onConfirmNo.bind(this));
        }

        _getNodeFromEvent(event) {
            const element = document.elementFromPoint(event.clientX, event.clientY);
            const nodeElement = element?.closest('.node-html');
            return nodeElement ? this.mindMap.getNodeById(nodeElement.dataset.nodeId) : null;
        }

        onPointerDown(event) {
            if (event.button !== 0 && event.pointerType === 'mouse') return;
            this.isMouseDown = true;
            this.potentialClick = true;
            this.lastPointerPos = { x: event.clientX, y: event.clientY };
            const target = event.target;
            const nodeElement = target.closest('.node-html');
            const node = nodeElement ? this.mindMap.getNodeById(nodeElement.dataset.nodeId) : null;

            // Check for specific control clicks first
            const controlButton = target.closest('.node-controls button, .node-quick-controls button');
            if (controlButton && node) {
                event.preventDefault(); event.stopPropagation();
                this.handleNodeControlClick(node, controlButton.dataset.action);
                this.hideContextMenu();
                return;
            }

            const resizeHandle = target.closest('.resize-handle');
            if (resizeHandle && node) {
                event.preventDefault(); event.stopPropagation();
                this.resizedNode = node;
                node.startResize();
                this.resizeStartPos = { x: event.clientX, y: event.clientY };
                this.resizeStartSize = { ...node.size };
                this.container.style.cursor = 'nwse-resize';
                this.hideContextMenu();
                return;
            }

            const contentEditable = target.closest('.node-content[contenteditable="true"]');
            if (nodeElement && !contentEditable) {
                event.preventDefault();
                this.draggedNode = node;
                if (this.draggedNode) {
                    this.draggedNode.startDrag();
                    const worldPos = this.mindMap.getWorldPositionFromScreen(event.clientX, event.clientY, this.draggedNode.position.z);
                    this.dragOffset.copy(worldPos ? worldPos.sub(this.draggedNode.position) : new THREE.Vector3());
                    this.container.style.cursor = 'grabbing';
                }
                this.hideContextMenu();
                return;
            }

            // If background clicked, check for edge selection
            if (!nodeElement && !controlButton && !resizeHandle && !contentEditable) {
                 const clickedEdge = this.mindMap.findClosestEdge(event.clientX, event.clientY);
                 this.mindMap.setSelectedEdge(clickedEdge); // Select or deselect edge
            } else {
                 this.mindMap.setSelectedEdge(null); // Deselect edge if clicking node/controls
            }

            this.hideContextMenu();
        }

        onPointerMove(event) {
            const dx = event.clientX - this.lastPointerPos.x;
            const dy = event.clientY - this.lastPointerPos.y;
            if (this.isMouseDown && (dx !== 0 || dy !== 0)) this.potentialClick = false;
            this.lastPointerPos = { x: event.clientX, y: event.clientY };

            if (this.mindMap.isLinking) this._updateTempLinkLine(event.clientX, event.clientY);

            // Highlight potential link targets
            const targetNode = this._getNodeFromEvent(event);
            $$('.node-html.linking-target').forEach(el => el.classList.remove('linking-target'));
            if (this.mindMap.isLinking && targetNode && targetNode !== this.mindMap.linkSourceNode) {
                targetNode.htmlElement?.classList.add('linking-target');
            }

            if (!this.isMouseDown) return; // Only handle drags/resizes if mouse is down

            if (this.resizedNode) {
                event.preventDefault();
                const newWidth = this.resizeStartSize.width + dx;
                const newHeight = this.resizeStartSize.height + dy;
                this.resizedNode.resize(newWidth, newHeight);
            } else if (this.draggedNode) {
                event.preventDefault();
                const worldPos = this.mindMap.getWorldPositionFromScreen(event.clientX, event.clientY, this.draggedNode.position.z);
                if (worldPos) this.draggedNode.drag(worldPos.sub(this.dragOffset));
            } else {
                // Background drag - handled by CameraController
            }
        }

        onPointerUp(event) {
            if (!this.isMouseDown && !this.mindMap.isLinking) return;

            this.container.style.cursor = this.mindMap.isLinking ? 'crosshair' : 'grab';

            if (this.resizedNode) {
                this.resizedNode.endResize();
                this.resizedNode = null;
            } else if (this.draggedNode) {
                const droppedOnNode = this._getNodeFromEvent(event);
                this.draggedNode.endDrag();
                this._checkPiling(this.draggedNode, droppedOnNode);
                this.draggedNode = null;
            } else if (this.mindMap.isLinking) {
                this._endLinking(event);
            } else if (this.potentialClick) {
                // Handle simple clicks (node, edge, background) - edge selection handled in pointerdown
                const clickedNode = this._getNodeFromEvent(event);
                if (clickedNode) {
                    // console.log("Clicked node:", clickedNode.id);
                } else if (!this.mindMap.selectedEdge) {
                    // console.log("Clicked background");
                } else {
                    // console.log("Clicked near edge:", this.mindMap.selectedEdge.id);
                }
            }

            this.isMouseDown = false;
            this.potentialClick = false;
            $$('.node-html.linking-target').forEach(el => el.classList.remove('linking-target'));
        }

        onContextMenu(event) {
            event.preventDefault();
            const targetNode = this._getNodeFromEvent(event);
            const targetEdge = !targetNode ? this.mindMap.findClosestEdge(event.clientX, event.clientY) : null;

            let items = [];
            if (targetNode) {
                items = [
                    { label: "Edit Content 📝", action: "edit-node", nodeId: targetNode.id, disabled: !(targetNode instanceof NoteNode) },
                    { label: "Start Link ✨", action: "start-link", nodeId: targetNode.id },
                    { label: "Focus Here 🎯", action: "focus-node", nodeId: targetNode.id },
                    { type: 'separator' },
                    { label: "Delete Node 🗑️", action: "delete-node", nodeId: targetNode.id },
                ];
            } else if (targetEdge) {
                this.mindMap.setSelectedEdge(targetEdge); // Select edge on right-click
                items = [
                    { label: `Edge: ${targetEdge.id.substring(0, 10)}...`, action: "noop", disabled: true },
                    { type: 'separator' },
                    { label: "Style: Elastic", action: "set-edge-style", edgeId: targetEdge.id, style: 'elastic', checked: targetEdge.data.style === 'elastic' },
                    { label: "Style: Rigid", action: "set-edge-style", edgeId: targetEdge.id, style: 'rigid', checked: targetEdge.data.style === 'rigid' },
                    { label: "Style: Ghost", action: "set-edge-style", edgeId: targetEdge.id, style: 'ghost', checked: targetEdge.data.style === 'ghost' },
                    { type: 'separator' },
                    { label: "Delete Edge 🗑️", action: "delete-edge", edgeId: targetEdge.id },
                ];
            } else {
                const worldPos = this.mindMap.getWorldPositionFromScreen(event.clientX, event.clientY, 0);
                items = [
                    { label: "Create Note ➕", action: "create-note", position: worldPos ? JSON.stringify(worldPos) : null },
                    { label: "Create Animated Node ✨", action: "create-pulse", position: worldPos ? JSON.stringify(worldPos) : null },
                    { type: 'separator' },
                    { label: "Center View 🧭", action: "center-view" },
                ];
                 this.mindMap.setSelectedEdge(null); // Deselect edge if right-clicking background
            }

            if (items.length > 0) this.showContextMenu(event.clientX, event.clientY, items);
            else this.hideContextMenu();
        }

        showContextMenu(x, y, items) {
            this.contextMenu.innerHTML = '';
            const ul = document.createElement('ul');
            items.forEach(item => {
                if (item.type === 'separator') {
                    ul.appendChild(document.createElement('hr'));
                    return;
                }
                const li = document.createElement('li');
                li.textContent = item.checked ? `✓ ${item.label}` : item.label;
                if (item.disabled) li.classList.add('disabled');
                Object.entries(item).forEach(([key, value]) => {
                    if (value !== undefined && value !== null && key !== 'label' && key !== 'disabled' && key !== 'checked' && key !== 'type') li.dataset[key] = value;
                });
                ul.appendChild(li);
            });
            this.contextMenu.appendChild(ul);

            const menuRect = this.contextMenu.getBoundingClientRect();
            let finalX = Math.max(5, Math.min(x, window.innerWidth - menuRect.width - 5));
            let finalY = Math.max(5, Math.min(y, window.innerHeight - menuRect.height - 5));

            this.contextMenu.style.left = `${finalX}px`;
            this.contextMenu.style.top = `${finalY}px`;
            this.contextMenu.style.display = 'block';
        }

        hideContextMenu = () => { if (this.contextMenu) this.contextMenu.style.display = 'none'; }

        onMenuClick(event) {
            const li = event.target.closest('li');
            if (!li || li.classList.contains('disabled')) return;
            const data = li.dataset;
            const action = data.action;
            this.hideContextMenu();

            switch (action) {
                case 'edit-node': this.mindMap.getNodeById(data.nodeId)?.htmlElement?.querySelector('.node-content')?.focus(); break;
                case 'delete-node': this.showConfirm(`Delete node "${data.nodeId.substring(0, 10)}..."?`, () => this.mindMap.removeNode(data.nodeId)); break;
                case 'delete-edge': this.showConfirm(`Delete edge "${data.edgeId.substring(0, 10)}..."?`, () => this.mindMap.removeEdge(data.edgeId)); break;
                case 'focus-node': this.mindMap.focusOnNode(this.mindMap.getNodeById(data.nodeId)); break;
                case 'create-note': case 'create-pulse': this._createNodeFromMenu(data, action); break;
                case 'center-view': this.mindMap.centerView(); break;
                case 'start-link': this._startLinking(this.mindMap.getNodeById(data.nodeId)); break;
                case 'set-edge-style': this.mindMap.getEdgeById(data.edgeId)?.setStyle(data.style); break;
            }
        }

        handleNodeControlClick(node, action) {
             switch (action) {
                case 'delete-node': this.showConfirm(`Delete node "${node.id.substring(0, 10)}..."?`, () => this.mindMap.removeNode(node.id)); break;
                case 'start-link': this._startLinking(node); break;
                case 'text-zoom-in': node.adjustTextZoom(0.1); break;
                case 'text-zoom-out': node.adjustTextZoom(-0.1); break;
                case 'scale-up': node.adjustScale(1.25); break;
                case 'scale-down': node.adjustScale(0.8); break;
            }
        }

        _createNodeFromMenu(data, action) {
            if (!data.position) return;
            const pos = JSON.parse(data.position);
            const newNode = action === 'create-note'
                ? this.mindMap.addNode(new NoteNode(pos, { content: 'New Note ✨' }))
                : this.mindMap.addNode(new PulsingNode(pos, { label: 'Animated ✨' }));

            this.mindMap.layoutEngine?.kick();
            setTimeout(() => {
                this.mindMap.focusOnNode(newNode);
                 if (action === 'create-note') newNode.htmlElement?.querySelector('.node-content')?.focus();
            }, 100);
        }

        _startLinking(sourceNode) {
            if (!sourceNode) return;
            this.mindMap.isLinking = true;
            this.mindMap.linkSourceNode = sourceNode;
            this.container.style.cursor = 'crosshair';
            this._startTempLinkLine(sourceNode);
        }

        showConfirm(message, onConfirm) { $('#confirm-message').textContent = message; this.confirmCallback = onConfirm; this.confirmDialog.style.display = 'block'; }
        hideConfirm = () => { this.confirmDialog.style.display = 'none'; this.confirmCallback = null; }
        onConfirmYes = () => { this.confirmCallback?.(); this.hideConfirm(); }
        onConfirmNo = () => { this.hideConfirm(); }

        _startTempLinkLine(sourceNode) {
            this._removeTempLinkLine();
            const material = new THREE.LineDashedMaterial({ color: 0xffaa00, linewidth: 2, dashSize: 8, gapSize: 4, transparent: true, opacity: 0.8, depthTest: false });
            const points = [sourceNode.position.clone(), sourceNode.position.clone()];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            this.mindMap.tempLinkLine = new THREE.Line(geometry, material);
            this.mindMap.tempLinkLine.computeLineDistances();
            this.mindMap.tempLinkLine.renderOrder = 1;
            this.mindMap.scene.add(this.mindMap.tempLinkLine);
        }

        _updateTempLinkLine(screenX, screenY) {
            if (!this.mindMap.tempLinkLine || !this.mindMap.linkSourceNode) return;
            const targetPos = this.mindMap.getWorldPositionFromScreen(screenX, screenY, this.mindMap.linkSourceNode.position.z);
            if (targetPos) {
                const positions = this.mindMap.tempLinkLine.geometry.attributes.position;
                positions.setXYZ(1, targetPos.x, targetPos.y, targetPos.z);
                positions.needsUpdate = true;
                this.mindMap.tempLinkLine.geometry.computeBoundingSphere();
                this.mindMap.tempLinkLine.computeLineDistances();
            }
        }

        _removeTempLinkLine() {
            if (this.mindMap.tempLinkLine) {
                this.mindMap.scene.remove(this.mindMap.tempLinkLine);
                this.mindMap.tempLinkLine.geometry?.dispose();
                this.mindMap.tempLinkLine.material?.dispose();
                this.mindMap.tempLinkLine = null;
            }
        }

        _endLinking(event) {
            this._removeTempLinkLine();
            const targetNode = this._getNodeFromEvent(event);
            if (targetNode && targetNode !== this.mindMap.linkSourceNode) {
                this.mindMap.addEdge(this.mindMap.linkSourceNode, targetNode);
            }
            this.mindMap.isLinking = false;
            this.mindMap.linkSourceNode = null;
            this.container.style.cursor = 'grab';
            $$('.node-html.linking-target').forEach(el => el.classList.remove('linking-target'));
        }

        _checkPiling(droppedNode, droppedOnNode) {
            if (!droppedNode || !this.mindMap.layoutEngine) return;
            const MAX_PILE_DISTANCE_SQ = 100 * 100;
            const PILE_STRENGTH = 0.05;

            const targetNode = droppedOnNode ?? [...this.mindMap.nodes.values()].find(otherNode =>
                otherNode !== droppedNode && droppedNode.position.distanceToSquared(otherNode.position) < MAX_PILE_DISTANCE_SQ
            );

            if (targetNode) {
                this.mindMap.layoutEngine.addTemporaryAttraction(droppedNode, targetNode, PILE_STRENGTH, 60);
                this.mindMap.layoutEngine.kick();
            }
        }

        removeNodeHTML = (nodeId) => $(`#node-html-${nodeId}`)?.remove();
    }

    class CameraController {
        isPanning = false;
        panStart = new THREE.Vector2();
        targetPosition = new THREE.Vector3();
        targetLookAt = new THREE.Vector3();
        currentLookAt = new THREE.Vector3();
        zoomSpeed = 0.0015;
        panSpeed = 0.8;
        minZoom = 30;
        maxZoom = 10000;
        dampingFactor = 0.15;
        animationFrameId = null;

        constructor(camera, domElement) {
            this.camera = camera;
            this.domElement = domElement;
            this.targetPosition.copy(camera.position);
            const initialDir = new THREE.Vector3();
            camera.getWorldDirection(initialDir);
            this.targetLookAt.copy(camera.position).addScaledVector(initialDir, 10);
            this.currentLookAt.copy(this.targetLookAt);
            this._bindEvents();
            this.update();
        }

        _bindEvents() {
            this.domElement.addEventListener('wheel', this.onWheel.bind(this), { passive: false });
            this.domElement.addEventListener('pointerdown', this.onPointerDown.bind(this));
            window.addEventListener('pointermove', this.onPointerMove.bind(this));
            window.addEventListener('pointerup', this.onPointerUp.bind(this));
        }

        _getPointerTargetType(event) {
            const el = event.target;
            return (el.closest('.node-html') || el.closest('.context-menu') || el.closest('.dialog')) ? 'ui' : 'background';
        }

        onPointerDown(event) {
            if (event.button === 0 && this._getPointerTargetType(event) === 'background') {
                event.preventDefault();
                this.isPanning = true;
                this.panStart.set(event.clientX, event.clientY);
                this.domElement.classList.add('panning');
                gsap.killTweensOf(this.targetPosition);
                gsap.killTweensOf(this.targetLookAt);
            }
        }

        onPointerMove(event) {
            if (!this.isPanning) return;
            event.preventDefault();
            const deltaX = event.clientX - this.panStart.x;
            const deltaY = event.clientY - this.panStart.y;
            const cameraZ = this.camera.position.distanceTo(this.currentLookAt);
            const vFOV = THREE.MathUtils.degToRad(this.camera.fov);
            const height = 2 * Math.tan(vFOV / 2) * Math.max(1, cameraZ);
            const panX = -(deltaX / this.domElement.clientHeight) * height * this.panSpeed;
            const panY = (deltaY / this.domElement.clientHeight) * height * this.panSpeed;
            const right = new THREE.Vector3().setFromMatrixColumn(this.camera.matrixWorld, 0);
            const up = new THREE.Vector3().setFromMatrixColumn(this.camera.matrixWorld, 1);
            const panOffset = right.multiplyScalar(panX).add(up.multiplyScalar(panY));
            this.targetPosition.add(panOffset);
            this.targetLookAt.add(panOffset);
            this.panStart.set(event.clientX, event.clientY);
        }

        onPointerUp(event) {
            if (this.isPanning && event.button === 0) {
                this.isPanning = false;
                this.domElement.classList.remove('panning');
            }
        }

        onWheel(event) {
            if (this._getPointerTargetType(event) !== 'background') return;
            event.preventDefault();
            gsap.killTweensOf(this.targetPosition);
            gsap.killTweensOf(this.targetLookAt);

            const delta = -event.deltaY * this.zoomSpeed;
            const currentDist = this.targetPosition.distanceTo(this.targetLookAt);
            let newDist = clamp(currentDist * Math.pow(0.95, delta * 10), this.minZoom, this.maxZoom);
            const zoomFactor = (newDist - currentDist) / currentDist;
            const mouseWorldPos = this._getLookAtPlaneIntersection(event.clientX, event.clientY);

            if (mouseWorldPos) {
                const zoomTargetVec = mouseWorldPos.clone().sub(this.targetPosition);
                this.targetPosition.addScaledVector(zoomTargetVec, zoomFactor);
            } else {
                const dir = new THREE.Vector3();
                this.camera.getWorldDirection(dir);
                this.targetPosition.addScaledVector(dir, newDist - currentDist);
            }
        }

        moveTo(x, y, z, duration = 0.7, lookAtTarget = null) {
            const targetPos = new THREE.Vector3(x, y, z);
            const targetLook = lookAtTarget ? lookAtTarget.clone() : new THREE.Vector3(x, y, 0);
            gsap.to(this.targetPosition, { x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: duration, ease: "power3.out", overwrite: true });
            gsap.to(this.targetLookAt, { x: targetLook.x, y: targetLook.y, z: targetLook.z, duration: duration, ease: "power3.out", overwrite: true });
        }

        update = () => {
            const delta = this.targetPosition.distanceTo(this.camera.position) + this.targetLookAt.distanceTo(this.currentLookAt);
            if (delta > 0.01 || this.isPanning) {
                this.camera.position.lerp(this.targetPosition, this.dampingFactor);
                this.currentLookAt.lerp(this.targetLookAt, this.dampingFactor);
                this.camera.lookAt(this.currentLookAt);
            } else {
                this.camera.position.copy(this.targetPosition);
                this.currentLookAt.copy(this.targetLookAt);
                this.camera.lookAt(this.currentLookAt);
            }
            this.animationFrameId = requestAnimationFrame(this.update);
        }

        dispose() { if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId); }

        _getLookAtPlaneIntersection(screenX, screenY) {
            const vec = new THREE.Vector3((screenX / window.innerWidth) * 2 - 1, -(screenY / window.innerHeight) * 2 + 1, 0.5);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(vec, this.camera);
            const camDir = new THREE.Vector3();
            this.camera.getWorldDirection(camDir);
            const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camDir, this.targetLookAt);
            const intersectPoint = new THREE.Vector3();
            return raycaster.ray.intersectPlane(plane, intersectPoint) ? intersectPoint : null;
        }
    }

    class ForceLayout {
        nodes = [];
        edges = [];
        velocities = new Map();
        fixedNodes = new Set();
        tempAttractions = [];
        isRunning = false;
        animationFrameId = null;
        settings = { repulsion: 8000, attraction: 0.03, idealEdgeLength: 200, centerStrength: 0.001, damping: 0.9, minEnergyThreshold: 0.05, gravityCenter: new THREE.Vector3(0, 0, 0), zSpreadFactor: 0.1, rigidAttractionFactor: 2.0 };

        constructor(mindMap) { this.mindMap = mindMap; }

        addNode(node) { if (!this.velocities.has(node.id)) { this.nodes.push(node); this.velocities.set(node.id, new THREE.Vector3()); } }
        removeNode(node) { this.nodes = this.nodes.filter(n => n !== node); this.velocities.delete(node.id); this.fixedNodes.delete(node); this.tempAttractions = this.tempAttractions.filter(a => a.nodeA !== node && a.nodeB !== node); }
        addEdge(edge) { if (!this.edges.includes(edge)) this.edges.push(edge); }
        removeEdge(edge) { this.edges = this.edges.filter(e => e !== edge); }
        fixNode(node) { this.fixedNodes.add(node); this.velocities.get(node.id)?.set(0, 0, 0); }
        releaseNode(node) { this.fixedNodes.delete(node); }
        addTemporaryAttraction(nodeA, nodeB, strength, duration = 60) { this.tempAttractions.push({ nodeA, nodeB, strength, duration }); }

        run(steps = 100) {
            this.isRunning = true;
            for (let i = 0; i < steps; i++) if (this._calculateStep() < this.settings.minEnergyThreshold) break;
            this.isRunning = false;
        }

        startContinuous() {
            if (this.animationFrameId) return;
            this.isRunning = true;
            const loop = () => {
                if (!this.isRunning) return;
                this._calculateStep();
                this.animationFrameId = requestAnimationFrame(loop);
            };
            this.animationFrameId = requestAnimationFrame(loop);
        }

        stopContinuous() { this.isRunning = false; if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; }

        kick(intensity = 1) {
            this.nodes.forEach(node => {
                if (!this.fixedNodes.has(node)) {
                    this.velocities.get(node.id)?.add(new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, (Math.random() - 0.5) * this.settings.zSpreadFactor).multiplyScalar(intensity * 5));
                }
            });
            if (!this.isRunning) this.startContinuous();
        }

        _calculateStep() {
            if (this.nodes.length < 2) return 0;
            let totalEnergy = 0;
            const forces = new Map(this.nodes.map(node => [node.id, new THREE.Vector3()]));
            const { repulsion, attraction, idealEdgeLength, centerStrength, gravityCenter, zSpreadFactor, rigidAttractionFactor } = this.settings;

            for (let i = 0; i < this.nodes.length; i++) {
                const nodeA = this.nodes[i];
                for (let j = i + 1; j < this.nodes.length; j++) {
                    const nodeB = this.nodes[j];
                    const delta = nodeB.position.clone().sub(nodeA.position);
                    let distSq = delta.lengthSq();
                    if (distSq < 1) { distSq = 1; delta.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(); }
                    const dist = Math.sqrt(distSq);
                    const nodeSizeFactor = (nodeA.size.width + nodeA.size.height + nodeB.size.width + nodeB.size.height) * 0.25;
                    const minSafeDist = nodeSizeFactor * 1.2;
                    const effectiveRepulsion = repulsion * (nodeSizeFactor / 100);
                    const forceMag = -effectiveRepulsion / Math.max(distSq, minSafeDist * minSafeDist * 0.5);
                    const forceVec = delta.normalize().multiplyScalar(forceMag);
                    forceVec.z *= zSpreadFactor;
                    forces.get(nodeA.id).add(forceVec);
                    forces.get(nodeB.id).sub(forceVec);
                }
            }

            this.edges.forEach(edge => {
                const { source, target, data } = edge;
                const delta = target.position.clone().sub(source.position);
                const dist = delta.length();
                if (dist < 0.1) return;
                const displacement = dist - idealEdgeLength;
                const edgeAttraction = data.style === 'rigid' ? attraction * rigidAttractionFactor : attraction;
                const forceMag = edgeAttraction * displacement;
                const forceVec = delta.normalize().multiplyScalar(forceMag);
                forceVec.z *= zSpreadFactor;
                if (data.style !== 'ghost') { // Ghost edges don't exert force
                    forces.get(source.id).add(forceVec);
                    forces.get(target.id).sub(forceVec);
                }
            });

            this.tempAttractions = this.tempAttractions.filter(attr => {
                const delta = attr.nodeB.position.clone().sub(attr.nodeA.position);
                const forceVec = delta.multiplyScalar(attr.strength);
                forceVec.z *= zSpreadFactor;
                forces.get(attr.nodeA.id).add(forceVec);
                forces.get(attr.nodeB.id).sub(forceVec);
                return --attr.duration > 0;
            });

            if (centerStrength > 0) {
                this.nodes.forEach(node => {
                    const forceVec = gravityCenter.clone().sub(node.position).multiplyScalar(centerStrength);
                    forceVec.z *= zSpreadFactor * 0.5;
                    forces.get(node.id).add(forceVec);
                });
            }

            this.nodes.forEach(node => {
                if (this.fixedNodes.has(node)) return;
                const force = forces.get(node.id);
                const velocity = this.velocities.get(node.id);
                velocity.add(force).multiplyScalar(this.settings.damping);
                node.position.add(velocity);
                totalEnergy += velocity.lengthSq();
            });

            return totalEnergy;
        }
    }

    function initializeNeuroWeaver() {
        const container = $('#mindmap-container');
        const statusIndicator = $('#status-indicator');
        if (!container) throw new Error("Mind map container not found!");

        const mindMap = new MindMap(container);
        const uiManager = new UIManager(mindMap);
        const cameraController = new CameraController(mindMap.camera, mindMap.container);
        const forceLayout = new ForceLayout(mindMap);

        mindMap.uiManager = uiManager;
        mindMap.cameraController = cameraController;
        mindMap.layoutEngine = forceLayout;

        loadExampleMindMap(mindMap);

        forceLayout.run(150);
        mindMap.centerView(null, 0);
        forceLayout.startContinuous();

        const clock = new THREE.Clock();
        function animate() {
            const time = clock.getElapsedTime();
            mindMap.update(time); // Pass time for potential animations
            mindMap.render();
            requestAnimationFrame(animate);
        }
        animate();

        statusIndicator.textContent = 'NeuroWeaver Ready ✨';
        setTimeout(() => statusIndicator.classList.add('hidden'), 1500);
    }

    function loadExampleMindMap(mindMap) {
        const n1 = mindMap.addNode(new NoteNode({ x: 0, y: 0, z: 0 }, { content: "<h1>🚀 NeuroWeaver v2 🧠</h1><p>Enhanced 3D Mind Mapping</p>✨" }));
        n1.setSize(300, 110);

        const n2 = mindMap.addNode(new NoteNode({ x: 300, y: 100, z: 20 }, { content: "<h2>New Features ✨</h2><ul><li>Node Quick Buttons (Text/Scale)</li><li>Edge Selection & Styling</li><li>Animated Node Type</li><li>Modular Structure</li><li>GSAP Animations</li></ul>" }));
        n2.setSize(240, 200); n2.adjustTextZoom(-0.1);

        const n3 = mindMap.addNode(new NoteNode({ x: -250, y: 150, z: -10 }, { content: "<h2>Technology 💻</h2><p><code>HTML</code>, <code>CSS</code>, <code>JavaScript (ESM)</code></p><p><b>Three.js</b> (WebGL + CSS3D)</p><p><b>GSAP</b> (Animation)</p><i>(Self-contained)</i>" }));
        n3.setSize(240, 150);

        const n4 = mindMap.addNode(new PulsingNode({ x: 0, y: -250, z: 0 }, { label: "<h2>Interactivity Demo 👆</h2><p>Right-click nodes, edges, or background!</p><p>Use quick buttons below nodes.</p>" }));
        n4.setSize(250, 130);

        const n5 = mindMap.addNode(new NoteNode({ x: 350, y: -150, z: -30 }, { content: "<h2>Edge Styles 🎨</h2><p>Right-click an edge:</p><ul><li><b>Elastic:</b> Default spring</li><li><b>Rigid:</b> Stronger pull</li><li><b>Ghost:</b> Visual only</li></ul>" }));
        n5.setSize(220, 160);

        mindMap.addEdge(n1, n2);
        mindMap.addEdge(n1, n3);
        mindMap.addEdge(n1, n4, { style: 'ghost' });
        mindMap.addEdge(n2, n5);
        mindMap.addEdge(n4, n5, { style: 'rigid' });
        mindMap.addEdge(n3, n2);
    }

    try {
        console.log("🧠 NeuroWeaver v2 Initializing...");
        initializeNeuroWeaver();
    } catch (error) {
        console.error("NeuroWeaver Initialization Failed:", error);
        $('#status-indicator').textContent = `Error: ${error.message}`;
        $('#status-indicator').style.backgroundColor = 'var(--delete-button-bg)';
        $('#status-indicator').style.transition = 'none';
        $('#status-indicator').classList.remove('hidden');
    }
</script>
</body>
</html>